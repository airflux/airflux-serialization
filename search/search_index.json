{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-airflux-serialization","title":"Welcome to Airflux serialization","text":"<p>The Kotlin library for parsing, validation, and generating data in the JSON (JavaScript Object Notation) format. The library doesn't use code generation or reflection.</p> <p>Documentation in progress.</p>"},{"location":"env/","title":"The environment","text":""},{"location":"env/#the-readers-environment","title":"The reader's environment","text":""},{"location":"env/#the-writers-environment","title":"The writer's environment","text":""},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#gradle","title":"Gradle","text":"<p>Added the repository</p> <pre><code>repositories {\n    maven {\n        url = uri(\"https://jitpack.io\")\n    }\n}\n</code></pre> <p>Added the serialization library</p> <pre><code>dependencies {\n    implementation(\"com.github.airflux.airflux:airflux-serialization-core:version\")\n    implementation(\"com.github.airflux.airflux:airflux-serialization-dsl:version\")\n    implementation(\"com.github.airflux.airflux:airflux-serialization-std:version\")\n}\n</code></pre> <p>Added the parser for JSON</p> <pre><code>dependencies {\n    implementation(\"com.github.airflux.airflux:airflux-jackson-parser:version\")\n    implementation(\"com.fasterxml.jackson.core:jackson-core:2.13.3\")\n    implementation(\"com.fasterxml.jackson.module:jackson-module-kotlin:2.13.3\") {\n        exclude(group = \"org.jetbrains.kotlin\")\n    }\n}\n</code></pre>"},{"location":"installation/#maven","title":"Maven","text":"<p>Added the repository</p> <pre><code>&lt;repositories&gt;\n    &lt;repository&gt;\n        &lt;id&gt;jitpack.io&lt;/id&gt;\n        &lt;url&gt;https://jitpack.io&lt;/url&gt;\n    &lt;/repository&gt;\n&lt;/repositories&gt;\n</code></pre> <p>Added the serialization library</p> <pre><code>&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.github.airflux.airflux&lt;/groupId&gt;\n        &lt;artifactId&gt;airflux-serialization-core&lt;/artifactId&gt;\n        &lt;version&gt;version&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.github.airflux.airflux&lt;/groupId&gt;\n        &lt;artifactId&gt;airflux-serialization-dsl&lt;/artifactId&gt;\n        &lt;version&gt;version&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.github.airflux.airflux&lt;/groupId&gt;\n        &lt;artifactId&gt;airflux-serialization-std&lt;/artifactId&gt;\n        &lt;version&gt;version&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre> <p>Added the parser for JSON</p> <pre><code>&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.github.airflux.airflux&lt;/groupId&gt;\n        &lt;artifactId&gt;airflux-jackson-parser&lt;/artifactId&gt;\n        &lt;version&gt;version&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.github.airflux.airflux&lt;/groupId&gt;\n        &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;\n        &lt;version&gt;2.13.3&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.github.airflux.airflux&lt;/groupId&gt;\n        &lt;artifactId&gt;jackson-module-kotlin&lt;/artifactId&gt;\n        &lt;version&gt;2.13.3&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>"},{"location":"quickstart/","title":"Quickstart","text":""},{"location":"quickstart/#the-domain-types","title":"The domain types","text":"<pre><code>data class User(val id: Int, val name: String, val phones: Phones)\ndata class Phones(private val items: List&lt;Phone&gt;) : List&lt;Phone&gt; by items\ndata class Phone(val title: String, val number: String)\n</code></pre>"},{"location":"quickstart/#configuration-the-jackson","title":"Configuration the Jackson","text":"<p>Registering the module 'AirFluxJsonModule' with Jackson to use its parser</p> <pre><code>val mapper = ObjectMapper().apply {\n    registerModule(AirFluxJsonModule)\n}\n</code></pre>"},{"location":"quickstart/#reading","title":"Reading","text":""},{"location":"quickstart/#the-example-of-json","title":"The example of JSON","text":"<pre><code>val JSON = \"\"\"\n{\n  \"id\": 42,\n  \"name\": \"User\",\n  \"phones\": [\n    {\n      \"title\": \"mobile\",\n      \"number\": \"+0123456789\"\n    }\n  ]\n}\n\"\"\"\n</code></pre>"},{"location":"quickstart/#deserialization-json","title":"Deserialization JSON","text":"<pre><code>val parsedUser = JSON.deserialization(\n    mapper = mapper,\n    env = readerEnv,\n    reader = UserReader\n).orThrow { IllegalStateException() }\n</code></pre>"},{"location":"quickstart/#define-the-environment-for-reading","title":"Define the environment for reading","text":"<p>Define the environment to deserialization of some domain type using the reader</p> <pre><code>val readerEnv = JsReaderEnv(\n    config = JsReaderEnv.Config(\n        errorBuilders = ReaderErrorBuilders,\n        options = ReaderOptions(failFast = true)\n    )\n)\n</code></pre> <ul> <li>Define error builders for the reading environment</li> </ul> <pre><code>object ReaderErrorBuilders : InvalidTypeErrorBuilder,\n                             PathMissingErrorBuilder,\n                             NumberFormatErrorBuilder,\n                             IsNotBlankStringValidator.ErrorBuilder,\n                             PatternStringValidator.ErrorBuilder,\n                             IsNotEmptyStructValidator.ErrorBuilder,\n                             AdditionalPropertiesStructValidator.ErrorBuilder,\n                             AdditionalItemsErrorBuilder,\n                             IsNotEmptyArrayValidator.ErrorBuilder,\n                             MinimumNumberValidator.ErrorBuilder {\n\n    //Reading error builders\n    override fun invalidTypeError(expected: JsValue.Type, actual: JsValue.Type): JsReaderResult.Error =\n        JsonErrors.InvalidType(expected = expected, actual = actual)\n\n    override fun pathMissingError(): JsReaderResult.Error = JsonErrors.PathMissing\n\n    override fun numberFormatError(value: String, target: KClass&lt;*&gt;): JsReaderResult.Error =\n        JsonErrors.NumberFormat(value, target)\n\n    //String validation error builders\n    override fun isNotBlankStringError(): JsReaderResult.Error = JsonErrors.Validation.Strings.IsBlank\n\n    override fun patternStringError(value: String, pattern: Regex): JsReaderResult.Error =\n        JsonErrors.Validation.Strings.Pattern(value, pattern)\n\n    //Object validation error builders\n    override fun isNotEmptyStructError(): JsReaderResult.Error = JsonErrors.Validation.Struct.IsEmpty\n\n    override fun additionalPropertiesStructError(): JsReaderResult.Error =\n        JsonErrors.Validation.Struct.AdditionalProperties\n\n    //Array validation error builders\n    override fun isNotEmptyArrayError(): JsReaderResult.Error = JsonErrors.Validation.Arrays.IsEmpty\n\n    override fun additionalItemsError(): JsReaderResult.Error = JsonErrors.Validation.Arrays.AdditionalItems\n\n    //Number validation error builders\n    override fun minimumNumberError(expected: Number, actual: Number): JsReaderResult.Error =\n        JsonErrors.Validation.Numbers.Min(expected = expected, actual = actual)\n}\n</code></pre> <ul> <li>Define parsing and validation errors</li> </ul> <pre><code>sealed class JsonErrors : JsReaderResult.Error {\n    data object PathMissing : JsonErrors()\n    data class InvalidType(val expected: JsValue.Type, val actual: JsValue.Type) : JsonErrors()\n    data class NumberFormat(val value: String, val type: KClass&lt;*&gt;) : JsonErrors()\n\n    sealed class Validation : JsonErrors() {\n        sealed class Struct : Validation() {\n            data object IsEmpty : Struct()\n            data object AdditionalProperties : Struct()\n        }\n\n        sealed class Arrays : Validation() {\n            data object IsEmpty : Arrays()\n            data object AdditionalItems : Arrays()\n        }\n\n        sealed class Strings : Validation() {\n            data object IsBlank : Strings()\n            class Pattern(val value: String, val pattern: Regex) : Strings()\n        }\n\n        sealed class Numbers : Validation() {\n            class Min&lt;T&gt;(val expected: T, val actual: T) : Numbers()\n        }\n    }\n}\n</code></pre> <ul> <li>Define the options for the reading environment</li> </ul> <pre><code>class ReaderOptions(override val failFast: Boolean) : FailFastOption\n</code></pre>"},{"location":"quickstart/#define-readers-for-domain-types","title":"Define readers for domain types","text":"<ul> <li>Define the generic readers</li> </ul> <pre><code>// Primitive type readers\nval intReader = IntReader.build&lt;ReaderErrorBuilders, ReaderOptions&gt;()\nval stringReader = StringReader.build&lt;ReaderErrorBuilders, ReaderOptions&gt;()\n\n// The generic reader for the id property\nval positiveNumberReader: JsReader&lt;ReaderErrorBuilders, ReaderOptions, Int&gt; =\n    intReader.validation(StdNumberValidator.minimum(0))\n\n// The generic reader for the username property\nval nonEmptyStringReader: JsReader&lt;ReaderErrorBuilders, ReaderOptions, String&gt; =\n    stringReader.validation(isNotBlank)\n\n// The reader for the phone number property\nval phoneNumberReader: JsReader&lt;ReaderErrorBuilders, ReaderOptions, String&gt; =\n    nonEmptyStringReader.validation(StdStringValidator.pattern(\"\\\\d*\".toRegex()))\n</code></pre> <ul> <li>Define the validators</li> </ul> <pre><code>//String validators\nval isNotBlank = StdStringValidator.isNotBlank&lt;ReaderErrorBuilders, ReaderOptions&gt;()\n\n//Object validators\nfun additionalProperties(properties: JsStructProperties&lt;ReaderErrorBuilders, ReaderOptions&gt;) =\n    StdStructValidator.additionalProperties(properties)\n\n//Array validators\nval isNotEmptyArray = StdArrayValidator.isNotEmpty&lt;ReaderErrorBuilders, ReaderOptions&gt;()\n</code></pre> <ul> <li>Define the reader for the Phone type</li> </ul> <pre><code>val phoneReader: JsReader&lt;ReaderErrorBuilders, ReaderOptions, Phone&gt; = structReader {\n    validation { properties -&gt; additionalProperties(properties) }\n\n    val title = property(required(name = \"title\", reader = nonEmptyStringReader))\n    val number = property(required(name = \"number\", reader = phoneNumberReader))\n\n    returns { _, location -&gt;\n        Phone(title = +title, number = +number).toSuccess(location)\n    }\n}\n</code></pre> <ul> <li>Define the reader for the Phones type</li> </ul> <pre><code>val phonesReader: JsReader&lt;ReaderErrorBuilders, ReaderOptions, Phones&gt; = arrayReader {\n    validation(isNotEmptyArray)\n    returns(items = phoneReader)\n}.map { phones -&gt; Phones(phones) }\n</code></pre> <ul> <li>Define the reader for the User type</li> </ul> <pre><code>val userReader: JsReader&lt;ReaderErrorBuilders, ReaderOptions, User&gt; = structReader {\n    val id = property(required(name = \"id\", reader = positiveNumberReader))\n    val name = property(required(name = \"name\", reader = nonEmptyStringReader))\n    val phones = property(optional(name = \"phones\", reader = phonesReader, default = { _, _ -&gt; Phones() }))\n\n    returns { _, location -&gt;\n        User(id = +id, name = +name, phones = +phones).toSuccess(location)\n    }\n}\n</code></pre>"},{"location":"quickstart/#writing","title":"Writing","text":""},{"location":"quickstart/#serialization-the-user-object","title":"Serialization the User object","text":"<pre><code>val user = User(id = 42, name = \"user\", phones = Phones(listOf(Phone(title = \"mobil\", number = \"123456789\"))))\nval json = user.serialization(mapper = mapper, env = writerEnv, writer = userWriter)\n</code></pre>"},{"location":"quickstart/#define-the-environment-to-serialization-of-some-domain-type-using-the-writer","title":"Define the environment to serialization of some domain type using the writer","text":"<pre><code>val writerEnv = JsWriterEnv(\n    config = JsWriterEnv.Config(\n        options = WriterOptions(writerActionIfResultIsEmpty = WriterActionIfResultIsEmpty.RETURN_NOTHING)\n    )\n)\n</code></pre> <ul> <li>Define the options for the writing environment</li> </ul> <pre><code>class WriterOptions(override val writerActionIfResultIsEmpty: WriterActionIfResultIsEmpty) :\n    WriterActionBuilderIfResultIsEmptyOption\n</code></pre>"},{"location":"quickstart/#define-the-writers-for-some-domain-types","title":"Define the writers for some domain types","text":"<ul> <li>Define the generic writers</li> </ul> <pre><code>val stringWriter = StringWriter.build&lt;WriterOptions&gt;()\nval intWriter = IntWriter.build&lt;WriterOptions&gt;()\n</code></pre> <ul> <li>Define the writer for the Phone type</li> </ul> <pre><code>val phoneWriter: JsWriter&lt;WriterOptions, Phone&gt; = structWriter {\n    property(nonNullable(name = \"title\", from = Phone::title, writer = stringWriter))\n    property(nonNullable(name = \"number\", from = Phone::number, writer = stringWriter))\n}\n</code></pre> <ul> <li>Define the writer for the Phones type</li> </ul> <pre><code>val phonesWriter: JsWriter&lt;WriterOptions, Iterable&lt;Phone&gt;&gt; = arrayWriter(phoneWriter)\n</code></pre> <ul> <li>Define the writer for the User type</li> </ul> <pre><code>val userWriter: JsWriter&lt;WriterOptions, User&gt; = structWriter {\n    property(nonNullable(name = \"id\", from = User::id, writer = intWriter))\n    property(nonNullable(name = \"name\", from = User::name, writer = stringWriter))\n    property(nonNullable(name = \"phones\", from = User::phones, writer = phonesWriter))\n}\n</code></pre>"},{"location":"readers/","title":"The Reader","text":"<p>Reader converters are used to convert from a ValueNode to another type.</p>"},{"location":"readers/#array-reared","title":"Array reared","text":""},{"location":"readers/#create-reader","title":"Create reader","text":""},{"location":"readers/#return-type-definition","title":"Return type definition","text":""},{"location":"readers/#addition-validation-to-reader","title":"Addition validation to reader","text":""},{"location":"readers/#struct-reared","title":"Struct reared","text":""},{"location":"readers/#create-reader_1","title":"Create reader","text":""},{"location":"readers/#defining-properties","title":"Defining properties","text":""},{"location":"readers/#return-type-definition_1","title":"Return type definition","text":""},{"location":"readers/#addition-validation-to-reader_1","title":"Addition validation to reader","text":""},{"location":"standard-tools/","title":"Standard tools","text":""},{"location":"standard-tools/#standard-readers","title":"Standard readers","text":"<ul> <li>Reader for the Byte type</li> <li>Reader for the Short type</li> <li>Reader for the Int type</li> <li>Reader for the Long type</li> <li>Reader for the Boolean type</li> <li>Reader for the String type</li> <li>Reader for the BigDecimal type</li> </ul>"},{"location":"standard-tools/#standard-writers","title":"Standard writers","text":"<ul> <li>Writer for the Byte type</li> <li>Writer for the Short type</li> <li>Writer for the Int type</li> <li>Writer for the Long type</li> <li>Writer for the Boolean type</li> <li>Writer for the String type</li> <li>Writer for the BigDecimal type</li> </ul>"},{"location":"standard-tools/#standard-validators","title":"Standard validators","text":""},{"location":"standard-tools/#the-string-validators","title":"The string validators","text":"<ul> <li>isNotEmpty</li> <li>isNotBlank</li> <li>pattern</li> <li>minLength</li> <li>maxLength</li> <li>isA</li> </ul>"},{"location":"standard-tools/#the-comparison-validators","title":"The comparison validators","text":"<ul> <li>min</li> <li>max</li> <li>eq</li> <li>ne</li> <li>gt</li> <li>ge</li> <li>lt</li> <li>le</li> </ul>"},{"location":"standard-tools/#the-array-validators","title":"The array validators","text":"<ul> <li>isNotEmpty</li> <li>minItems</li> <li>maxItems</li> </ul>"},{"location":"standard-tools/#the-struct-validators","title":"The struct validators","text":"<ul> <li>additionalProperties</li> <li>isNotEmpty</li> <li>minProperties</li> <li>maxProperties</li> </ul>"},{"location":"writers/","title":"The Writer","text":"<p>Writer converters are used to convert from some type to a ValueNode.</p>"},{"location":"writers/#array-writer","title":"Array writer","text":""},{"location":"writers/#create-writer","title":"Create writer","text":""},{"location":"writers/#struct-writer","title":"Struct writer","text":""},{"location":"writers/#create-writer_1","title":"Create writer","text":""}]}