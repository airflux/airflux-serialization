{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Airflux serialization The library to parse, validate and generate data in the JSON (JavaScript Object Notation) format.","title":"Home"},{"location":"#welcome-to-airflux-serialization","text":"The library to parse, validate and generate data in the JSON (JavaScript Object Notation) format.","title":"Welcome to Airflux serialization"},{"location":"installation/","text":"Installation Gradle Added the repository repositories { ... maven { url = uri(\"https://jitpack.io\") } } Added the serialization library dependencies { implementation(\"com.github.airflux.airflux:airflux-serialization:version\") } Added the parser for JSON dependencies { implementation(\"com.github.airflux.airflux:airflux-jackson-parser:version\") implementation(\"com.fasterxml.jackson.core:jackson-core:2.13.3\") implementation(\"com.fasterxml.jackson.module:jackson-module-kotlin:2.13.3\") { exclude(group = \"org.jetbrains.kotlin\") } } Maven Added the repository <repositories> <repository> <id>jitpack.io</id> <url>https://jitpack.io</url> </repository> </repositories> Added the serialization library <dependency> <groupId>com.github.airflux.airflux</groupId> <artifactId>airflux-serialization</artifactId> <version>version</version> </dependency> Added the parser for JSON <dependency> <groupId>com.github.airflux.airflux</groupId> <artifactId>airflux-jackson-parser</artifactId> <version>version</version> </dependency> <dependency> <groupId>com.github.airflux.airflux</groupId> <artifactId>jackson-core</artifactId> <version>2.13.3</version> </dependency> <dependency> <groupId>com.github.airflux.airflux</groupId> <artifactId>jackson-module-kotlin</artifactId> <version>2.13.3</version> </dependency>","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#gradle","text":"Added the repository repositories { ... maven { url = uri(\"https://jitpack.io\") } } Added the serialization library dependencies { implementation(\"com.github.airflux.airflux:airflux-serialization:version\") } Added the parser for JSON dependencies { implementation(\"com.github.airflux.airflux:airflux-jackson-parser:version\") implementation(\"com.fasterxml.jackson.core:jackson-core:2.13.3\") implementation(\"com.fasterxml.jackson.module:jackson-module-kotlin:2.13.3\") { exclude(group = \"org.jetbrains.kotlin\") } }","title":"Gradle"},{"location":"installation/#maven","text":"Added the repository <repositories> <repository> <id>jitpack.io</id> <url>https://jitpack.io</url> </repository> </repositories> Added the serialization library <dependency> <groupId>com.github.airflux.airflux</groupId> <artifactId>airflux-serialization</artifactId> <version>version</version> </dependency> Added the parser for JSON <dependency> <groupId>com.github.airflux.airflux</groupId> <artifactId>airflux-jackson-parser</artifactId> <version>version</version> </dependency> <dependency> <groupId>com.github.airflux.airflux</groupId> <artifactId>jackson-core</artifactId> <version>2.13.3</version> </dependency> <dependency> <groupId>com.github.airflux.airflux</groupId> <artifactId>jackson-module-kotlin</artifactId> <version>2.13.3</version> </dependency>","title":"Maven"},{"location":"quickstart/","text":"Quickstart Reading JSON The example of JSON to be parsing, validation and matching to some types. { \"id\": 42, \"name\": \"User\", \"phones\": [ { \"title\": \"mobile\", \"number\": \"+0123456789\" } ] } The domain types data class User(val id: Int, val name: String, val phones: Phones) data class Phones(private val items: List<Phone>) : List<Phone> by items data class Phone(val title: String, val number: String) Readers Define the parsing and validation errors sealed class JsonErrors : ReaderResult.Error { object PathMissing : JsonErrors() data class InvalidType(val expected: ValueNode.Type, val actual: ValueNode.Type) : JsonErrors() data class ValueCast(val value: String, val type: KClass<*>) : JsonErrors() sealed class Validation : JsonErrors() { sealed class Object : Validation() { object IsEmpty : Object() object AdditionalProperties : Object() } sealed class Arrays : Validation() { object IsEmpty : Arrays() } sealed class Strings : Validation() { object IsEmpty : Strings() class Pattern(val value: String, val regex: Regex) : Strings() } sealed class Numbers : Validation() { class Gt<T>(val expected: T, val actual: T) : Numbers() } } } Define the config for an object reader builder val ObjectReaderConfiguration = objectReaderConfig { validation { +StdObjectValidator.isNotEmpty } } Define the default context for an object reader val DefaultReaderContext = readerContext { failFast = false //registering the object validation error builders +IsNotEmptyObjectValidator.ErrorBuilder { JsonErrors.Validation.Object.IsEmpty } +AdditionalPropertiesObjectValidator.ErrorBuilder { JsonErrors.Validation.Object.AdditionalProperties } //registering the array validation error builders +IsNotEmptyArrayValidator.ErrorBuilder { JsonErrors.Validation.Arrays.IsEmpty } //registering the string validation error builders +IsNotEmptyStringValidator.ErrorBuilder { JsonErrors.Validation.Strings.IsEmpty } +PatternStringValidator.ErrorBuilder(JsonErrors.Validation.Strings::Pattern) //registering the number validation error builders +GtComparisonValidator.ErrorBuilder(JsonErrors.Validation.Numbers::Gt) //registering the parsing error builders +PathMissingErrorBuilder { JsonErrors.PathMissing } +InvalidTypeErrorBuilder(JsonErrors::InvalidType) +ValueCastErrorBuilder(JsonErrors::ValueCast) } Define the config for an array reader builder val ArrayReaderConfiguration = arrayReaderConfig { validation { +StdArrayValidator.isNotEmpty } } Define the context for an array reader. val DefaultWriterContext = writerContext() Define the readers for domain type. The generic readers // The generic reader for the id property val PositiveNumberReader: Reader<Int> = IntReader.validation(StdComparisonValidator.gt(0)) // The generic reader for the username property val NonEmptyStringReader: Reader<String> = StringReader.validation(StdStringValidator.isNotBlank) // The reader for the phone number property val PhoneNumberReader: Reader<String> = NonEmptyStringReader.validation(StdStringValidator.pattern(\"\\\\d*\".toRegex())) Reader for the Phone type val PhoneReader = structReader<Phone>(ObjectReaderConfiguration) { validation { +StdObjectValidator.additionalProperties } val title = property(required(name = \"title\", reader = NonEmptyStringReader)) val number = property(required(name = \"number\", reader = PhoneNumberReader)) returns { _, _ -> Phone(title = +title, number = +number).success() } } Reader for the Phones type val PhonesReader = arrayReader(ArrayReaderConfiguration) { returns(items = nonNullable(PhoneReader)) }.map { phones -> Phones(phones) } Reader for the User type val UserReader = structReader<User>(ObjectReaderConfiguration) { val id = property(required(name = \"id\", reader = PositiveNumberReader)) val name = property(required(name = \"name\", reader = NonEmptyStringReader)) val phones = property(optionalWithDefault(name = \"phones\", reader = PhonesReader, default = { _, _ -> Phones() })) returns { _, _ -> User(id = +id, name = +name, phones = +phones).success() } } Writing Writers Define the config for an object writer builder. Define the context for an object writer. val DefaultWriterContext = writerContext() Define the config for an array writer builder. Define the context for an array writer. Define the writers for domain type. Writer for the Phone type val PhoneWriter = structWriter<Phone> { property(nonNullable(name = \"title\", from = Phone::title, writer = StringWriter)) property(nonNullable(name = \"number\", from = Phone::number, writer = StringWriter)) } Writer for the Phones type val PhonesWriter = arrayWriter<Phone> { items(nullable(PhoneWriter)) } Writer for the User type val UserWriter = structWriter<User> { property(nonNullable(name = \"id\", from = User::id, writer = IntWriter)) property(nonNullable(name = \"name\", from = User::name, writer = StringWriter)) property(nonNullable(name = \"phones\", from = User::phones, writer = PhonesWriter)) }","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"","title":"Quickstart"},{"location":"quickstart/#reading","text":"","title":"Reading"},{"location":"quickstart/#json","text":"The example of JSON to be parsing, validation and matching to some types. { \"id\": 42, \"name\": \"User\", \"phones\": [ { \"title\": \"mobile\", \"number\": \"+0123456789\" } ] }","title":"JSON"},{"location":"quickstart/#the-domain-types","text":"data class User(val id: Int, val name: String, val phones: Phones) data class Phones(private val items: List<Phone>) : List<Phone> by items data class Phone(val title: String, val number: String)","title":"The domain types"},{"location":"quickstart/#readers","text":"","title":"Readers"},{"location":"quickstart/#define-the-parsing-and-validation-errors","text":"sealed class JsonErrors : ReaderResult.Error { object PathMissing : JsonErrors() data class InvalidType(val expected: ValueNode.Type, val actual: ValueNode.Type) : JsonErrors() data class ValueCast(val value: String, val type: KClass<*>) : JsonErrors() sealed class Validation : JsonErrors() { sealed class Object : Validation() { object IsEmpty : Object() object AdditionalProperties : Object() } sealed class Arrays : Validation() { object IsEmpty : Arrays() } sealed class Strings : Validation() { object IsEmpty : Strings() class Pattern(val value: String, val regex: Regex) : Strings() } sealed class Numbers : Validation() { class Gt<T>(val expected: T, val actual: T) : Numbers() } } }","title":"Define the parsing and validation errors"},{"location":"quickstart/#define-the-config-for-an-object-reader-builder","text":"val ObjectReaderConfiguration = objectReaderConfig { validation { +StdObjectValidator.isNotEmpty } }","title":"Define the config for an object reader builder"},{"location":"quickstart/#define-the-default-context-for-an-object-reader","text":"val DefaultReaderContext = readerContext { failFast = false //registering the object validation error builders +IsNotEmptyObjectValidator.ErrorBuilder { JsonErrors.Validation.Object.IsEmpty } +AdditionalPropertiesObjectValidator.ErrorBuilder { JsonErrors.Validation.Object.AdditionalProperties } //registering the array validation error builders +IsNotEmptyArrayValidator.ErrorBuilder { JsonErrors.Validation.Arrays.IsEmpty } //registering the string validation error builders +IsNotEmptyStringValidator.ErrorBuilder { JsonErrors.Validation.Strings.IsEmpty } +PatternStringValidator.ErrorBuilder(JsonErrors.Validation.Strings::Pattern) //registering the number validation error builders +GtComparisonValidator.ErrorBuilder(JsonErrors.Validation.Numbers::Gt) //registering the parsing error builders +PathMissingErrorBuilder { JsonErrors.PathMissing } +InvalidTypeErrorBuilder(JsonErrors::InvalidType) +ValueCastErrorBuilder(JsonErrors::ValueCast) }","title":"Define the default context for an object reader"},{"location":"quickstart/#define-the-config-for-an-array-reader-builder","text":"val ArrayReaderConfiguration = arrayReaderConfig { validation { +StdArrayValidator.isNotEmpty } }","title":"Define the config for an array reader builder"},{"location":"quickstart/#define-the-context-for-an-array-reader","text":"val DefaultWriterContext = writerContext()","title":"Define the context for an array reader."},{"location":"quickstart/#define-the-readers-for-domain-type","text":"The generic readers // The generic reader for the id property val PositiveNumberReader: Reader<Int> = IntReader.validation(StdComparisonValidator.gt(0)) // The generic reader for the username property val NonEmptyStringReader: Reader<String> = StringReader.validation(StdStringValidator.isNotBlank) // The reader for the phone number property val PhoneNumberReader: Reader<String> = NonEmptyStringReader.validation(StdStringValidator.pattern(\"\\\\d*\".toRegex())) Reader for the Phone type val PhoneReader = structReader<Phone>(ObjectReaderConfiguration) { validation { +StdObjectValidator.additionalProperties } val title = property(required(name = \"title\", reader = NonEmptyStringReader)) val number = property(required(name = \"number\", reader = PhoneNumberReader)) returns { _, _ -> Phone(title = +title, number = +number).success() } } Reader for the Phones type val PhonesReader = arrayReader(ArrayReaderConfiguration) { returns(items = nonNullable(PhoneReader)) }.map { phones -> Phones(phones) } Reader for the User type val UserReader = structReader<User>(ObjectReaderConfiguration) { val id = property(required(name = \"id\", reader = PositiveNumberReader)) val name = property(required(name = \"name\", reader = NonEmptyStringReader)) val phones = property(optionalWithDefault(name = \"phones\", reader = PhonesReader, default = { _, _ -> Phones() })) returns { _, _ -> User(id = +id, name = +name, phones = +phones).success() } }","title":"Define the readers for domain type."},{"location":"quickstart/#writing","text":"","title":"Writing"},{"location":"quickstart/#writers","text":"","title":"Writers"},{"location":"quickstart/#define-the-config-for-an-object-writer-builder","text":"","title":"Define the config for an object writer builder."},{"location":"quickstart/#define-the-context-for-an-object-writer","text":"val DefaultWriterContext = writerContext()","title":"Define the context for an object writer."},{"location":"quickstart/#define-the-config-for-an-array-writer-builder","text":"","title":"Define the config for an array writer builder."},{"location":"quickstart/#define-the-context-for-an-array-writer","text":"","title":"Define the context for an array writer."},{"location":"quickstart/#define-the-writers-for-domain-type","text":"Writer for the Phone type val PhoneWriter = structWriter<Phone> { property(nonNullable(name = \"title\", from = Phone::title, writer = StringWriter)) property(nonNullable(name = \"number\", from = Phone::number, writer = StringWriter)) } Writer for the Phones type val PhonesWriter = arrayWriter<Phone> { items(nullable(PhoneWriter)) } Writer for the User type val UserWriter = structWriter<User> { property(nonNullable(name = \"id\", from = User::id, writer = IntWriter)) property(nonNullable(name = \"name\", from = User::name, writer = StringWriter)) property(nonNullable(name = \"phones\", from = User::phones, writer = PhonesWriter)) }","title":"Define the writers for domain type."}]}